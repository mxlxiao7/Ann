package com.ann.function.thread.exchanger;

import com.ann.utils.Utils;

import java.util.concurrent.Exchanger;

/**
 * 当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，
 * 然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；
 * 或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。
 * <p>
 * 原理:
 * 我们假定一个空的栈（Stack），栈顶（Top）当然是没有元素的。同时我们假定一个数据结构Node，包含一个要交换的元素E和
 * 一个要填充的“洞”Node。这时线程T1携带节点node1进入栈（cas_push)，当然这是CAS操作，这样栈顶就不为空了。线程T2携
 * 带节点node2进入栈，发现栈里面已经有元素了node1，同时发现node1的hold（Node）为空，于是将自己（node2）填充到
 * node1的hold中（cas_fill）。然后将元素node1从栈中弹出（cas_take）。这样线程T1就得到了node1.hold.item也就是
 * node2的元素e2，线程T2就得到了node1.item也就是e1，从而达到了交换的目的。
 * <p>
 * 要点:
 * 此类提供对外的操作是同步的；
 * 用于成对出现的线程之间交换数据；
 * 可以视作双向的同步队列；
 * 可应用于基因算法、流水线设计等场景。
 * <p>
 * 实战场景：
 * 1.问题描述
 * 最近接到外部项目组向我组提出的接口需求，需要查询我们业务办理量的统计情况。我们系统目前的情况是，有一个日增长十多万、
 * 总数据量为千万级别的业务办理明细表（xxx_info），每人次的业务办理结果会实时写入其中。以往对外提供的业务统计接口是在
 * 每次被调用时候在明细表中执行SQL查询（select、count、where、group by等），响应时间很长，对原生产业务的使用也有很
 * 大的影响。于是我决定趁着这次新增接口的上线机会对系统进行优化。
 * 2.优化思路
 * 首先是在明细表之外再建立一个数据统计（xxx_statistics）表，考虑到目前数据库的压力以及公司内部质管流控等因素，暂没
 * 有分库存放，仍旧与原明细表放在同一个库。再设置一个定时任务于每日凌晨对明细表进行查询、过滤、统计、排序等操作，把统计
 * 结果插入到统计表中。然后对外暴露统计接口查询统计报表。现在的设计与原来的实现相比，虽然牺牲了统计表所占用的少量额外
 * 的存储空间（每日新增的十来万条业务办理明细记录经过处理最终会变成几百条统计表的记录），但是却能把select、count这样
 * 耗时的数据统计操作放到凌晨时段执行以避开白天的业务办理高峰，分表处理能够大幅降低对生产业务明细表的性能影响，而对外提
 * 供的统计接口的查询速度也将得到几个数量级的提升。当然，还有一个缺点是，不能实时提供当天的统计数据，不过这也是双方可以
 * 接受的。
 * 3.设计实现
 * 设计一个定时任务，每日凌晨执行。在定时任务中启动两个线程，一个线程负责对业务明细表（xxx_info）进行查询统计，把统计
 * 的结果放置在内存缓冲区，另一个线程负责读取缓冲区中的统计结果并插入到业务统计表（xxx_statistics）中。
 * 亲，这样的场景是不是听起来很有感觉？没错!两个线程在内存中批量交换数据，这个事情我们可以使用Exchanger去做！我们马上
 * 来看看代码如何实现
 */
public class ExchangerDemo {

    public static void main() {
        new Thread(() -> new ExchangerDemo().doAction()).start();
    }

    public void doAction() {
        Exchanger<String> exchanger = new Exchanger();
        Car car = new Car(exchanger);
        Bike bike = new Bike(exchanger);
        car.start();
        bike.start();
        Utils.msg("Main end!");
    }
}
